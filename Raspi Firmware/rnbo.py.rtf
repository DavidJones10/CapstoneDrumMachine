{\rtf1\ansi\ansicpg1252\cocoartf2639
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\csgray\c0;}
\margl1440\margr1440\vieww13520\viewh15480\viewkind0
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f0\fs22 \cf2 \CocoaLigature0 import os\
# Set the DISPLAY variable for pygame to detect it\
os.environ["DISPLAY"] = ":0"\
import pygame\
from numpy import interp\
import sys\
import time\
import board\
import busio\
import digitalio\
from adafruit_mcp230xx.mcp23017 import MCP23017\
from adafruit_mcp3xxx.mcp3008 import MCP3008\
from adafruit_mcp3xxx.analog_in import AnalogIn\
from digitalio import Direction, Pull\
import liblo as OSC\
import multiprocessing\
import Adafruit_GPIO.SPI as SPI\
from pygame.locals import *\
from extra_rnbo import mySwitch, myLed, myMap, scale, getRandomPattern, MyRotaryEncoder\
from rnbo_display import Display\
display = Display(12)\
\
isLooping = False\
multifunction = False\
reverseDrum = False\
reverseLoop = False\
reverseAll = False\
fillMode = False\
djmMode = False\
tempo = 120\
previousValue = True\
encValue = 0\
#fx_selection = 0\
#drumButtonMode = 0\
sequenceIndex = 0\
last_fx = 0\
try:\
    target = OSC.Address(1234)\
except OSC.AddressError as err:\
    print(err)\
    sys.exit()\
try:\
    server = OSC.Server(4321)\
except OSC.ServerError as err:\
        print(err)\
\
# create pins for SPI and i2c\
spi1 = busio.SPI(board.SCK_1,board.MOSI_1,board.MISO_1)\
i2c = busio.I2C(board.SCL, board.SDA)\
\
# create the cs (chip select) pins\
cs1 = digitalio.DigitalInOut(board.D17)\
cs2 = digitalio.DigitalInOut(board.D18)\
\
mcp = MCP23017(i2c, address=0x21)\
mcp2 = MCP23017(i2c, address=0x20)\
mcp3 = MCP23017(i2c, address=0x22)\
adc = MCP3008(spi1,cs1)\
adc2 = MCP3008(spi1,cs2)\
\
# initialize the switches\
switches = []\
leds = [] #pattern leds\
leds2 = [] #sequence and fx leds\
for i in range(0,16):\
    switches.append(mySwitch(mcp2,i))\
    #leds.append(myLed(mcp,i))\
    leds2.append(myLed(mcp3,i))\
\
adcValues = []\
adcValues2 = []\
for i in range(0,8):\
    leds.append(myLed(mcp,i+8))\
    adcValues.append(AnalogIn(adc,i))\
    adcValues2.append(AnalogIn(adc2,i))\
\
original_drum_arrays  = [[0, 0, 0, 0, 0, 0, 0, 0],\
                        [0, 0, 0, 0, 0, 0, 0, 0],\
                        [0, 0, 0, 0, 0, 0, 0, 0],\
                        [0, 0, 0, 0, 0, 0, 0, 0],\
                        [0, 0, 0, 0, 0, 0, 0, 0],\
                        [0, 0, 0, 0, 0, 0, 0, 0],\
                        [0, 0, 0, 0, 0, 0, 0, 0]]\
\
#enc0 = Encoder.Encoder(12, 6)\
enc0 = MyRotaryEncoder(mcp2,14,15,target,0)\
enc1 = MyRotaryEncoder(mcp,0,1,target,1)\
enc2 = MyRotaryEncoder(mcp,2,3,target,2)\
enc3 = MyRotaryEncoder(mcp,4,5,target,3)\
enc4 = MyRotaryEncoder(mcp,6,7,target,4)\
#enc2 = MyRotaryEncoder(12, 6, max_steps = maxsteps)\
#enc3 = MyRotaryEncoder(13, 5, max_steps = maxsteps)\
#enc\
def reset_leds():\
    for led in leds:\
        led.setValue(False)\
    for led in leds2:\
        led.setValue(False)\
def reset_drums(drumArrays):\
    startText = "/rnbo/inst/0/params/toggleParams/toggle"\
    for row in range(7):\
        OSC.send(target,"/rnbo/inst/0/params/drumMode",row)\
        for j in range(8):\
            drumArrays[row][j] = 0\
            text = startText + str(j)\
            OSC.send(target,text,0)\
    OSC.send(target,"/rnbo/inst/0/params/Looper/clearRecording")\
def drumLogic(drumArrays,drumButtonMode,screen_mode):\
    global multifunction\
    if switches[8].Value():\
        multifunction = True\
        OSC.send(target,"/rnbo/inst/0/params/multifunction",1)\
    else:\
        multifunction = False\
        OSC.send(target,"/rnbo/inst/0/params/multifunction",0)\
    OSC.send(target,"/rnbo/inst/0/params/drumMode",int(drumButtonMode.value))\
    if drumButtonMode.value == 0:\
        controlsToArrays(drumArrays[0],drumButtonMode,drumArrays,screen_mode)\
    elif drumButtonMode.value == 1:\
        controlsToArrays(drumArrays[1],drumButtonMode,drumArrays,screen_mode)\
    elif drumButtonMode.value == 2:\
        controlsToArrays(drumArrays[2],drumButtonMode,drumArrays,screen_mode)\
    elif drumButtonMode.value == 3:\
        controlsToArrays(drumArrays[3],drumButtonMode,drumArrays,screen_mode)\
    elif drumButtonMode.value == 4:\
        controlsToArrays(drumArrays[4],drumButtonMode,drumArrays,screen_mode)\
    elif drumButtonMode.value == 5:\
        controlsToArrays(drumArrays[5],drumButtonMode,drumArrays,screen_mode)\
    elif drumButtonMode.value == 6:\
        controlsToArrays(drumArrays[6],drumButtonMode,drumArrays,screen_mode)\
    elif drumButtonMode.value == 7:\
        loopMode(drumButtonMode, drumArrays,screen_mode)\
    else:\
        drumButtonMode.value = 0\
def loopMode(drumButtonMode,drumArrays,screen_mode):\
    global multifunction\
    if multifunction:\
        leds[drumButtonMode.value].setValue(True)\
        for num, button in enumerate(switches[:8]):\
            if not num == drumButtonMode:\
                leds[num].setValue(False)\
            if button.risingEdge():\
                drumButtonMode.value = num\
            secondaryControls(drumButtonMode.value,drumArrays,screen_mode)\
    else:\
        primaryControls(drumButtonMode.value,drumArrays,screen_mode)\
        if switches[0].Value() and switches[1].Value() and switches[6].Value() and switches[7].Value():\
            sys.exit()\
        if switches[0].timeHeld() > 7:\
            os.system("sudo reboot")\
def controlsToArrays(drumArr,drumButtonMode,drumArrays,screen_mode):\
    global multifunction\
    if not multifunction:\
        startText = "/rnbo/inst/0/params/toggleParams/toggle"\
        for num, button in enumerate(switches[:8]):\
            if  button.risingEdge():\
                screen_mode.value = 0 # THIS CHANGES THE SCREEN MODE\
                drumArr[num] = not drumArr[num]\
                #print("Button# ", num, "pressed!")\
            #print(num)\
            text = startText + str(num)\
            OSC.send(target,text,int(drumArr[num]))\
            leds[num].setValue(drumArr[num])\
            primaryControls(drumButtonMode.value,drumArrays,screen_mode)\
    else:\
        leds[drumButtonMode.value].setValue(True)\
        for num, button in enumerate(switches[:8]):\
            if not num == drumButtonMode:\
                leds[num].setValue(False)\
            if button.risingEdge():\
                drumButtonMode.value = num\
                if num == 7:\
                    screen_mode.value = 1\
            secondaryControls(drumButtonMode.value,drumArrays,screen_mode)\
\
def primaryControls(drumButtonMode,drumArrays,screen_mode):\
    global fillMode\
    if switches[9].risingEdge():\
        OSC.send(target,"/rnbo/inst/0/params/setWarp",1)\
        screen_mode.value = 1\
    if  switches[10].Value(False):\
        OSC.send(target,"/rnbo/inst/0/params/PausePlay",1)\
    else:\
        OSC.send(target,"/rnbo/inst/0/params/PausePlay",0)\
    global isLooping\
    if switches[11].risingEdge():\
        isLooping = not isLooping\
    if switches[11].timeHeld() > 2:\
        OSC.send(target,"/rnbo/inst/0/params/Looper/clearRecording")\
        isLooping = False\
        OSC.send(target,"/rnbo/inst/0/params/Looper/recordLoop",0)\
    if switches[12].Value() and switches[13].Value():\
        OSC.send(target,"/rnbo/inst/0/params/rdmSel",1)\
        screen_mode.value = 1\
    else:\
        if switches[12].risingEdge():\
            screen_mode.value = 0\
            fillMode = not fillMode\
        if switches[13].risingEdge():\
            screen_mode.value = 0\
            if drumButtonMode != 7:\
                getRandomPattern(drumButtonMode, drumArrays)\
    if switches[13].timeHeld() > 2:\
        screen_mode.value = 0\
        startText = "/rnbo/inst/0/params/toggleParams/toggle"\
        for row in range(7):\
            OSC.send(target,"/rnbo/inst/0/params/drumMode",row)\
            for j in range(8):\
                drumArrays[row][j] = 0\
                text = startText + str(j)\
                OSC.send(target,text,0)\
    if isLooping:\
        OSC.send(target,"/rnbo/inst/0/params/Looper/recordLoop",1)\
    else:\
        OSC.send(target,"/rnbo/inst/0/params/Looper/recordLoop",0)\
    if fillMode:\
        OSC.send(target,"/rnbo/inst/0/params/fillMode",1)\
    else:\
        OSC.send(target,"/rnbo/inst/0/params/fillMode",0)\
\
def secondaryControls(drumButtonMode,drumArrays,screen_mode):\
    global reverseAll\
    global reverseDrum\
    global djmMode\
    global reverseLoop\
    if  switches[10].Value(False):\
        OSC.send(target,"/rnbo/inst/0/params/PausePlay",1)\
    else:\
        OSC.send(target,"/rnbo/inst/0/params/PausePlay",0)\
    if (switches[9].Value() and switches[11].risingEdge()) or (switches[9].risingEdge() and switches[11].Value()):\
        reverseAll = not reverseAll\
        screen_mode.value = 1\
    else:\
        if switches[9].risingEdge():\
            reverseDrum = not reverseDrum\
        if switches[11].risingEdge():\
            reverseLoop = not reverseLoop\
    if switches[12].Value() and switches[13].Value():\
        #print("pleaseeeee")\
        screen_mode.value = 1\
        OSC.send(target,"/rnbo/inst/0/params/randomSounds",1)\
    else:\
        startText = "/rnbo/inst/0/params/toggleParams/toggle"\
        if switches[12].risingEdge():\
            djmMode = not djmMode\
            screen_mode.value = 0\
        if switches[13].risingEdge():\
            screen_mode.value = 0\
            for i in range(7):\
                getRandomPattern(i,drumArrays)\
                OSC.send(target,"/rnbo/inst/0/params/drumMode",i)\
                for num in range(8):\
                    text = startText + str(num)\
                    OSC.send(target,text,int(drumArrays[i][num]))\
\
    if reverseLoop:\
        OSC.send(target,"/rnbo/inst/0/params/Looper/reverseLoop",1)\
    else:\
        OSC.send(target,"/rnbo/inst/0/params/Looper/reverseLoop",0)\
\
    if reverseDrum:\
        OSC.send(target,"/rnbo/inst/0/params/reverseDrum",1)\
    else:\
        OSC.send(target,"/rnbo/inst/0/params/reverseDrum",0)\
\
    if djmMode:\
        OSC.send(target,"/rnbo/inst/0/params/djmMode",1)\
    else:\
        OSC.send(target,"/rnbo/inst/0/params/djmMode",0)\
\
    if reverseAll:\
        OSC.send(target,"/rnbo/inst/0/params/reverseAll",1)\
    else:\
        OSC.send(target,"/rnbo/inst/0/params/reverseAll",0)\
\
def handle_index(path,args):\
    minus2 = args[0]-1\
    if minus2 < 0:\
        minus2 = 7\
    #print("step: ", minus2)\
    index = minus2\
    leds2[index].setValue(True)\
    for i in range(8):\
        if not i == index:\
            leds2[i].setValue(False)\
\
def assign_array(path,args,value_array,fx_selection):\
    for i in range(len(args)):\
        value_array[i] = args[i]\
    leds2[fx_selection.value+8+1].setValue(True)\
    for i in range(5):\
        if i != fx_selection.value:\
            leds2[i+8+1].setValue(False)\
\
def encoder_stuff(screen_mode):\
    enc0.read_encoder()\
    if enc1.read_encoder():\
        screen_mode.value = 1\
    if enc2.read_encoder():\
        screen_mode.value = 1\
    if enc3.read_encoder():\
        screen_mode.value = 2\
    if enc4.read_encoder():\
        screen_mode.value = 2\
def analog_controls(fx_selection,screen_mode):\
    maxVal = 60000\
    minVal = 2000\
    OSC.send(target,"/rnbo/inst/0/params/drum1Vol",myMap(adcValues2[0].value,minVal,maxVal))\
    OSC.send(target,"/rnbo/inst/0/params/drum2Vol",myMap(adcValues2[1].value,minVal,maxVal))\
    OSC.send(target,"/rnbo/inst/0/params/drum3Vol",myMap(adcValues2[2].value,minVal,maxVal))\
    OSC.send(target,"/rnbo/inst/0/params/drum4Vol",myMap(adcValues2[3].value,minVal,maxVal))\
    OSC.send(target,"/rnbo/inst/0/params/drum5Vol",myMap(adcValues2[4].value,minVal,maxVal))\
    OSC.send(target,"/rnbo/inst/0/params/drum6Vol",myMap(adcValues2[5].value,minVal,maxVal))\
    OSC.send(target,"/rnbo/inst/0/params/drum7Vol",myMap(adcValues2[6].value,minVal,maxVal))\
    OSC.send(target,"/rnbo/inst/0/params/loopVol",myMap(adcValues2[7].value,minVal,maxVal))\
    OSC.send(target,"/rnbo/inst/0/params/inVol",myMap(adcValues[0].value,minVal,maxVal))\
    OSC.send(target,"/rnbo/inst/0/params/EQ_Low",scale(adcValues[1].value,minVal,maxVal,-1,1))\
    OSC.send(target,"/rnbo/inst/0/params/EQ_Mid",scale(adcValues[2].value,minVal,maxVal,-1,1))\
    OSC.send(target,"/rnbo/inst/0/params/EQ_High",scale(adcValues[3].value,minVal,maxVal,-1,1))\
    OSC.send(target,"/rnbo/inst/0/params/gain",myMap(adcValues[5].value,minVal,maxVal))\
    fx_selection.value = scale(adcValues[4].value,minVal, maxVal-5000,0,4,True)\
    global last_fx\
    if fx_selection.value != last_fx:\
        screen_mode.value = 2\
        last_fx = fx_selection.value\
    OSC.send(target,"/rnbo/inst/0/params/fxMode",fx_selection.value)\
    #print(fx_selection)\
\
server.add_method("/rnbo/inst/0/messages/out/step","i",lambda path, args: handle_index(path, args))\
server.add_method("/rnbo/inst/0/messages/out/valueArray","ffffffffffffffffffffffffffffffffffffffffffffffffff",lambda path, args: assign_array(path, args, value_array,fx_selection))\
OSC.send(target, "/rnbo/listeners/add", f"127.0.0.1:4321")\
\
def server_stuff(fx_selection,value_array):\
    try:\
        while True:\
            server.recv(0)\
    except KeyboardInterrupt:\
        reset_leds()\
        print("exiting cleanly...")\
\
def button_stuff(queue,drum_button_mode,screen_mode):\
    try:\
        drum_arrays = [[0, 0, 0, 0, 0, 0, 0, 0],\
                       [0, 0, 0, 0, 0, 0, 0, 0],\
                       [0, 0, 0, 0, 0, 0, 0, 0],\
                       [0, 0, 0, 0, 0, 0, 0, 0],\
                       [0, 0, 0, 0, 0, 0, 0, 0],\
                       [0, 0, 0, 0, 0, 0, 0, 0],\
                       [0, 0, 0, 0, 0, 0, 0, 0]]\
        while True:\
            drumLogic(drum_arrays,drum_button_mode,screen_mode)\
            encoder_stuff(screen_mode)\
            queue.put(drum_arrays)\
    except KeyboardInterrupt:\
        reset_leds()\
        reset_drums(drum_arrays)\
        print("exiting cleanly...")\
def screen_stuff(fx_selection,queue,drum_button_mode,value_array,screen_mode):\
    try:\
        display = Display(12)\
        while True:\
            drum_arrays = queue.get()\
            for event in pygame.event.get():\
                if event.type == pygame.QUIT:\
                    return\
            analog_controls(fx_selection,screen_mode) \
            display.draw(drum_arrays,drum_button_mode,value_array,screen_mode)\
    except KeyboardInterrupt:\
        reset_leds()\
        reset_drums(drum_arrays)\
        pygame.quit()\
        sys.exit()\
        print("exiting cleanly...")\
\
if __name__ == "__main__":\
    queue= multiprocessing.Queue()\
    value_array = multiprocessing.Array('f',50)\
    fx_selection = multiprocessing.Value('i',0)\
    screen_mode = multiprocessing.Value('i',0)\
    drum_button_mode = multiprocessing.Value('i',0)\
\
    buttons_process = multiprocessing.Process(target=button_stuff,args=(queue,drum_button_mode,screen_mode))\
    server_process = multiprocessing.Process(target=server_stuff,args=(fx_selection,value_array,))\
    screen_process = multiprocessing.Process(target=screen_stuff,args=(fx_selection,queue,drum_button_mode,value_array,screen_mode))\
    server_process.start()\
    screen_process.start()\
    buttons_process.start()\
    server_process.join()\
    screen_process.join()\
    buttons_process.join()\
#End Loop\
}